
計算機程式作業


==============================================================================
Data Structure 14
==============================================================================

01. 實作stack和circular queue

-------------------------
輸入說明:
-------------------------
先輸入要實作stack還是circular queue:
1表示實作stack
2表示實作circular queue
接著輸入想要執行的功能:
1表示新增整數數字到stack或circular queue
2表示想要刪除stack或circular queue裡面的數字
3表示印出目前stack或circular queue裡面的所有數字

stack和circular queue的MAX為5
如果沒有辦法新增數字到stack或circular queue則需顯示"FULL"
如果stack或circular queue為空導致沒有辦法刪除數字，則需顯示"EMPTY"

輸出說明:
印出程式執行結果。

---------------------------------------------------------------
input:
1
1 2
1 6
1 8
1 5
1 9
1 7

output:
FULL

input:
1
1 2
1 6
1 8
1 5
1 9
2
2
2
3
output:
2 6

input:
2
1 2
1 6
1 8
1 5
1 9
output:
FULL

input:
2
1 2
1 6
1 8
1 5
2
2
2
1 3
3
output:
5 3

input:
2
1 2
1 6
1 8
1 5
2
2
2
2
2
output:
EMPTY

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

02.

中序轉後序

給予一個由變數加上+-*/四則運算與冪次^運算的數學式，變數用一個小寫英文字母表示。
運算優先次序是：冪次大於乘除大於加減。中序表示法是運算符號在兩運算子中間，可藉括號表示優先運算次序。
請將用中序表示的運算式改成後序表示。後序表示法不需藉由括號區分運算的先後次序。

輸出說明
一行長度在512個字母內的字串，用中序表示法表達的算式。

輸出說明：後序表示的算式。
--------------------------------
input:
a+b*(c-d)^e

output:
abcd-e^*+

input:
(a-b)^c+(d-e)^f

output:
ab-c^de-f^+


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

03.

賴先生騎腳踏車挑戰一日N 城市，N<10。
城市編號 1, 2, 3, ...,N 。
城市間可能有一段距離的公路相連。
總共有 M 條公路連接兩個城市之間， N-1 < M < (N*N-1) / 2。
公路是雙向的，也就是說第 1 城市可以到第 2 城市，同理第 2 城市也能到第 1 城市。
並且一定會有一種以上的走法，可以從第 1 個城市出發，走遍所有其他的城市一次。

請計算從第 1 個城市出發，騎過每一個城市一次的最短距離。



例如 N = 5，以下是兩兩城市之間公路的距離。

-- 1   2   3   4   5
1  0   4   2   3   6
2  4   0   3   1   4
3  2   3   0   2   5
4  3   1   2   0   3
5  6   4   5   3   0

例如
城市 1 和城市 2 的距離是 4，
城市 1 和城市 3 的距離是 2，
城市 3 和城市 4 的距離是 2，
城市 5 和城市 4 的距離是 3，

則從城市 1 出發，騎完所有城市的距離最短是，
經由 13245 的距離 = 2+3+1+3= 9。

----------
輸入說明

第 1 筆資料是 N,M， N是城市個數，M是城市間有公路相連的個數。
第 2 筆資料是 I,J,K，I是編號 I 城市，J 是編號 J 城市，K是兩城市間公路距離。
第 3 筆資料是 I,J,K，I是編號 I 城市，J 是編號 J 城市，K是兩城市間公路距離。
....
第 M+1筆資料是是 I,J,K，I是編號 I 城市，J 是編號 J 城市，K是兩城市間公路距離。

--------
輸出說明

輸出從第 1 個城市出發，騎完所有城市最短距離。

--------
Sample Input

5,10
1,2,4
1,3,2
1,4,3
1,5,6
2,3,3
2,4,1
2,5,4
3,4,2
3,5,5
4,5,3

--------
Sample Output
9

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

04.

血緣關係


針對家族成員和成員間血緣關係的家族族譜，0 是 7 的孩子，1、2 和 3 是 0 的孩子，
4 和 5 是 1 的孩子，6 是 3 的孩 子。
最遠的親戚關係為 4(或 5)和 6，其"血緣距離"是 4 (4~1，1~0， 0~3，3~6)。
給予任一家族的關係圖，請找出所有成員的 "血緣距離"。
假設只有一個人是整個家族成員的祖先，而且沒有兩個成員有同樣的小孩。


7
|
0------
|  |  |
1  2  3----6
|----
|   |
4   5

輸入格式
第一行為一正整數 n 代表成員個數，每人以 0~n-1 間惟一編號代表。接著n-1 行，
每行有兩個以一個空白隔開的整數 a 與 b (0 ? a, b ? n-1)，代表 b 是 a 的 孩子。

輸出格式
輸出所有成員"血緣距離"。

範例：

輸入
8
0 1
0 2
0 3
7 0
1 4
1 5
3 6

輸出
0-1-1
0-2-1
0-3-1
0-4-2
0-5-2
0-6-2
0-7-1
1-2-2
1-3-2
1-4-1
1-5-1
1-6-3
1-7-2
2-3-2
2-4-3
2-5-3
2-6-3
2-7-2
3-4-3
3-5-3
3-6-1
3-7-2
4-5-2
4-6-4
4-7-3
5-6-4
5-7-3
6-7-3


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
05.


同學要選老師做專題 (project)，
N 位學生 (N student)，M 位老師 (M teacher) ，
配對方式，優先根據學生填寫志願，
如有相沖突，則考慮老師志願序。

測試案例一：
學生有4位分別為W、X、Y、Z
老師有4位分別為A、B、C、D
學生志願序：
W：A、B、C、D
X：A、C、B、D
Y：D、B、C、A
Z：B、C、A、D
老師志願序：
A：W、X、Y、Z
B：X、W、Y、Z
C：Y、Z、W、X
D：X、W、Z、Y
結果：
W->A
X->C
Y->D
Z->B


A,B,C,D
A,C,B,D
D,B,C,A
B,C,A,D
X,W,Y,Z
X,W,Y,Z
Y,Z,W,X
X,W,Z,Y

測試案例二：
學生志願序：
W：A、B、C、D
X：A、C、B、D
Y：D、B、C、A
Z：B、C、A、D


老師志願序：
A：X、W、Y、Z
B：X、W、Y、Z
C：Y、Z、W、X
D：X、W、Z、Y
結果：
W->C
X->A
Y->D
Z->B


範例輸入
A,B,C,D
A,C,B,D
D,B,C,A
B,C,A,D
W,X,Y,Z
X,W,Y,Z
Y,Z,W,X
X,W,Z,Y
範例輸出
W->A
X->C
Y->D
Z->B

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
06.

建構唯一二元樹

給定前序或後序以及中序，產生唯一個Binary Tree，依序印出Tree的內容，印出順序，由上而下，由左而右印出。

前序代碼：P
中序代碼：I
後序代碼：O

--------------
輸入說明

第一筆輸入前序、中序或後序代碼。
第二筆輸入上一筆輸入種類尋訪的結果，大寫英文字母。
第三筆輸入前序、中序或後序代碼。
第四筆輸入上一筆輸入種類尋訪的結果，大寫英文字母。

-------------
輸出說明

輸出為一二元樹的內容，由上而下，由左而右。

-------------
Sample input

P
ABCDEFGHI
I
BCAEDGHFI

--------------
Sample output

ABDCEFGIH

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

07.

binary tree


typedef struct node_s {
	int data;
	struct node_s * left;
	struct node_s * right;
} node_t;

typedef struct node_s {
	node_t * root;
}

typedef node_t * nodep_t;

以data大小為依據，左子樹小於等於根，右子樹大於根，建立二元樹。
//插入資料進二元樹
(1)void Insert(nodep_t *node, student_t key);
//中序巡訪印出：左中右
(2)void Inorder(nodep_t *node);

---------------------
輸入說明：

p function(2)
i function(1)
5 欲插入的數字
p
i
6
p
i
7
p
i
3
p
i
4
p
e 結束輸入
------------------------------
輸出說明：

p (印出):
(1)沒有tree 印出 null
(2)第一個插入的數字為 root
(3)小於、等於 root 為左子樹
(4)大於 root 為右子樹
3 4 5 6 7 每個data中間有空白

----------------------
Sample Input:

p
i
5
p
i
6
p
i
7
p
i
3
p
i
4
p
i
2
p
i
6
p
e

-------------------
Sample Output:

null
5
5 6
5 6 7
3 5 6 7
3 4 5 6 7
2 3 4 5 6 7
2 3 4 5 6 6 7

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

08.

Depth-first search for Binary Tree

typedef struct node_s {
	char data;
	struct node_s * left;
	struct node_s * mid;
	struct node_s * right;
} node_t;

typedef struct node_s {
	node_t * root;
}

typedef node_t * nodep_t;

//s為樹的敘述，第一個字元為Root
//(1)例如ACBE，則Root為A，left為C，mid為B，right為E
//(2.1)若先輸入DE，則Root為D，left為E
//(2.2)再輸入DF，則此時Root為D，left為E，mid為F
(1)void BuildTree(nodep_t *node, char* s);
//利用Depth-first search，尋訪規則為Root先拜訪，再由children中字元最小的開始尋訪
(2)void DFS(nodep_t *node);

---------------------
輸入說明：

i, 樹的敘述: function(1)
p: function(2)
e: 程式結束

輸出說明：

p (印出):
(1)沒有tree 印出 null
(2)每個data中間沒空白
---------------------
Sample Input:
p
i
ACBE
i
CD
i
DH
i
EF
p
i
HJ
i
HG
i
GI
p
e

Sample Output:
null
ABCDHEF
ABCDHGIJEF

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
09.

小英要為登玉山準備，練習爬 101大樓的樓梯。
可以一步踏一階、二階、最長跨三階。因此有很多種爬階方法。
例如要爬到第三階，有四種爬法:
(1)一次一階。
(2)先爬二階，再爬一階
(3)先爬一階，再爬二階
(4)一次三階。

要爬到第四階，有七種爬法。

最大要爬 70 層。

此程式執行時間不可超過 8 秒。

Hint:
1. 一次可跨 1~n 階時(n>=1)，從第 n+1 階開始，其全部方法為前 n 階方法數總和。
   若 n=3, f(n) = f(n-1) + f(n-2) + f(n-3)

2. 請考慮使用遞迴與非遞迴方法，或配合指標使用。

3. 請使用 unsifned long long int x;printf("%lld", x);



輸入說明
-----------------
整數 K，K<70，代表共爬 K 階。


輸出說明
-----------------
整數 M，代表共有幾種爬法。


Sample Input
-----------------
4


Sample Output
--------------
7

Sample Input
-----------------
12


Sample Output
--------------
927


Sample Input
-----------------
67


Sample Output
--------------
333269972246340068

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
10.

數位電路模擬I

寫一個程式模擬一個數位電路。
輸入 n 是二進位 8 位元，輸出是二進位 4 位元。
輸入範圍從 00000000 到 11111111 (十進位 0~255).

此數位電路內具有回饋迴路，其功能如下:
C(m) = m           if m = 0 or m = 1
C(m) = C(m/2)      if m is even
C(m) = C((m+1)/2)  if m is odd
此電路有一個紀錄器，會記錄跑過幾次回饋迴路，最後輸出為回饋電路跑過的次數。

例如 m=00001010(十進位 10)，則電路內部運算回饋電路輸入依序為十進位 5, 3, 2, 1。
C(10)= C(5)=C(3)=C(2)=C(1)=1
共跑過 4 次。則此電路輸出為 0100 (十進位 4)。


輸入說明:
二進位 8 bit 位元
第一行是第一個測試案例資料
接著是一行 0 分隔測試資料
第三行是第二個測試案例資料
....
最後 -1 結束

輸出說明:
二進位 4 bit 位元
每一行是一個測試案例資料的結果

Sample Input:
00000000
0
11111111
0
00000001
0
10000000
0
00111111
-1

Sample Output:
0000
1000
0000
0111
0110

=============================================================================================

11.

數位電路模擬II

寫一個程式模擬一個數位電路。
輸入 n 是二進位 8 位元，輸出是二進位 11 位元。
輸入範圍從 00000000 到 11111111 (十進位 0~255).

此數位電路內具有回饋迴路，其功能如下:
C(m) = m           if m = 0 or m = 1
C(m) = C(m/2)      if m is even
C(m) = C((m+1)/2)  if m is odd
此電路有一個紀錄器，會記錄跑過幾次回饋迴路。

例如 m=00001010(十進位 10)，則電路內部運算回饋電路輸入依序為十進位 5, 3, 2, 1。
C(10)= C(5)=C(3)=C(2)=C(1)=1
共跑過 4 次。則 R(10)=4。

例如 m=00000011(十進位 3)，則電路內部運算回饋電路輸入依序為十進位 2, 1。
C(3)= C(2)=C(1)=1
共跑過 2 次。則 R(3)=2。


此電路另有一個紀錄器，會記錄 m=0, m=1, m=2, ..m=n，所跑過幾次回饋迴路的加總。
即 R(0)+R(1)+...+R(n)。此即最後的輸出。

假設輸入 n = 3，此電路輸出為 R(0)+R(1)+R(2)+R(3)=0+0+1+2=3 (二進位 0011)。


輸入說明:
二進位 8 bit 位元
第一行是第一個測試案例資料
接著是一行 0 分隔測試資料
第三行是第二個測試案例資料
....
最後 -1 結束

輸出說明:
二進位 11 bit 位元
每一行是一個測試案例資料的結果

Sample Input:
00000000
0
11111111
0
10101010
-1


Sample Output:
00000000000
11011111001
10001010001

=============================================================================================

12.


葛雷碼 (Gray code)

反射二進位編碼-葛雷碼 (Gray code)，是編碼成兩個連續的位元不同。
輸入 n ，編碼範圍 0<=i<=2^n-1。
n = 3，編碼 0~7為 000, 001, 011, 010, 110, 111, 101, 100。

其編碼方式如下

G_1   = {0, 1}
G_1_r = {1, 0}

G_n      = {0G_(n-1), 1G_(n-1)_r }
if G_n   = {g1, g2, g3, ..., gn}
   G_n_r = {g_n, g_(n-1), g_(n-2), ..., g_1}

[G_n_r 是 G_n 的逆向順序]

G_(n+1)   = {0G_n, 1G_n_r}

例如

G_2   = {0G_1, 1G_1_r} = {00, 01, 11, 10}
G_2_r = {10, 11, 01, 00}

G_3   = {0G_2, 1G_2_r} = {000, 001, 011, 010, 110, 111, 101, 100}
G_3_r =                  {100, 101, 111, 110, 010, 011, 001, 000}

G_4   = {0000, 0001, 0011, 0010, 0110, 0111, 0101, 0100, 1100, 1101, 1111, 1110, 1010, 1011, 1001, 1000}
G_4_r = {1000, 1001, 1011, 1010, 1110, 1111, 1101, 1100, 0100, 0101, 0111, 0110, 0010, 0011, 0001, 0000}

其遞迴公式為，
G(n, k) = k                 if n=1
G(n, k) = 0G(n-1, k)        if k<2^(n-1)
G(n, k) = 1G(n-1, 2^n-1-k)  if k>=2^(n-1)

當 G(4, 7) = 0G(4-1, 7) = 0G(3, 7) = 01G(3-1, 2^3-1-7) = 01G(2, 0) =  010G(2-1, 0) = 010G(1, 0) = 0100

依此撰寫遞迴程式，輸入n, k，輸出 Gray code。

輸入說明:

第一行是一個測試案例資料，整數 n k
接著是一行 0 分隔測試資料
第三行是第二個測試案例資料
最後 -1 結束

-----------
輸出說明:

二進位 Gray code
每一行是一個測試案例資料的結果

Sample Input:
1 1
0
2 3
0
3 6
0
4 12
-1

Sample Output:
1
10
101
1010

=============================================================================================

13.

下圖 8 x 8 迷宮地圖中，1 代表牆壁，0 代表可走路徑。

1 1 1 1 1 1 1 1
1 0 0 0 0 0 0 1
1 1 1 0 1 1 1 1
1 0 0 0 0 0 0 1
1 1 0 1 0 1 1 1
1 1 0 1 0 0 0 1
1 1 0 1 1 1 0 1
1 1 1 1 1 1 1 1

請設計一個遞迴程式，找出從左上角出發，到右下角的路徑，
將 0 以 # 標示輸出，如下圖。

1 1 1 1 1 1 1 1
1 # # # 0 0 0 1
1 1 1 # 1 1 1 1
1 0 0 # # 0 0 1
1 1 0 1 # 1 1 1
1 1 0 1 # # # 1
1 1 0 1 1 1 # 1
1 1 1 1 1 1 1 1


輸入說明:
第 1 行輸入 n，n<40
第 2 行到第 n+1 行，為 n x n 地圖資料輸入，1 代表牆壁，0 代表可走路徑。
左上角[1][1]的 0 為起點，右下角 [n-2][n-2]的 0 為終點。

輸出說明:
第 1 行到第 n 行，為地圖與可走路徑，可走路徑以 # 標示。

Smaple Input
8
1 1 1 1 1 1 1 1
1 0 0 0 0 0 0 1
1 1 1 0 1 1 1 1
1 0 0 0 0 0 0 1
1 1 0 1 0 1 1 1
1 1 0 1 0 0 0 1
1 1 0 1 1 1 0 1
1 1 1 1 1 1 1 1

Sample Output
1 1 1 1 1 1 1 1
1 # # # 0 0 0 1
1 1 1 # 1 1 1 1
1 0 0 # # 0 0 1
1 1 0 1 # 1 1 1
1 1 0 1 # # # 1
1 1 0 1 1 1 # 1
1 1 1 1 1 1 1 1


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

14.

寫一個程式求解 N 元一次聯立方程式

c11X1 + c12X2 +..+ C1nXn = A1
c21X1 + c22X2 +..+ C2nXn = A2
.....
cn1X1 + cn2X2 +..+ CnnXn = An


其中cij為整數。
解答若不為整數，必須以分數顯示。
本題解答一定有唯一解。

-----------------------------
輸入格式說明：

變數個數 N
方程式 1 係數
方程式 2 係數
....
方程式 N 係數

------------------------

輸出格式說明
X[1]=變數 1 解答
X[2]=變數 2 解答

X[N]=變數 N 解答

-------------------------
Sample Input

3
1 -1 1 4
3 2 1 2
4 2 2 8

------------------------
Sample output

X[1] = -4
X[2] = 2
X[3] = 10
